apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: {{.Values.serviceName}}
  namespace: {{.Values.serviceNamespace}}
  labels:
    app: {{.Values.ciEnvironmentSlug}}
    pipeline_id: "{{.Values.ciPipelineId}}"
    build_id: "{{.Values.ciBuildId}}"
spec:
  replicas: {{.Values.replicas}}
  template:
    metadata:
      labels:
        name: {{.Values.serviceName}}
        app: {{.Values.ciEnvironmentSlug}}
    spec:
      imagePullSecrets:
        - name: {{.Values.privateRegistryKey}}
      containers:
          # Golang Image
        - image: {{.Values.serviceImage}}:{{.Values.serviceImageTag}}
          name: {{.Values.serviceName}}
          env:
            - name: SERVICE_NAME
              value: {{.Values.serviceName}}
            - name: SERVICE_TYPE
              value: {{.Values.serviceType}}
            - name: SERVICE_SCOPE
              value: {{.Values.serviceScope}}
            - name: CI_PIPELINE_ID
              value: "{{.Values.ciPipelineId}}"
            - name: CI_BUILD_ID
              value: "{{.Values.ciBuildId}}"
            - name: SERVICE_ENVIRONMENT
              value: "{{.Values.serviceEnvironment}}"
            - name: SERVICE_BRANCH
              value: "{{.Values.serviceBranch}}"
            {{- range $name, $value := .Values.envVars }}
            - name: {{ $name }}
              value: {{ $value | quote }}
            {{- end}}
          imagePullPolicy: {{.Values.pullPolicy}}
          # If we want to mount the service's directory for local development we'll need to use the persistent volume claim create bellow.
          {{- if .Values.developmentVolumeMapping}}
          volumeMounts:
          - mountPath: "/var/www/html"
            name: {{.Values.serviceName}}
          #- end of developmentVolumeMapping
          {{- end }}
      volumes:
        # If we want to mount the service's directory for local development we'll need to use add the volumes to the pods.
        {{- if .Values.developmentVolumeMapping}}
        - name: {{.Values.serviceName}}
          persistentVolumeClaim:
            claimName: {{.Values.serviceName}}
        {{- end }}

{{- if .Values.podAutoscaling}}

---

apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: {{.Values.serviceName}}
  namespace: {{.Values.serviceNamespace}}
  labels:
    app: {{.Values.ciEnvironmentSlug}}
    pipeline_id: "{{.Values.ciPipelineId}}"
    build_id: "{{.Values.ciBuildId}}"
spec:
  scaleTargetRef:
    apiVersion: extensions/v1beta1
    kind: Deployment
    name: {{.Values.serviceName}}
  minReplicas: 3
  maxReplicas: 100
  targetCPUUtilizationPercentage: 50

# end of podAutoscaling
{{- end }}

# If we want to mount the service's directory for local development we'll need create a PersistentVolume and PersistentVolume Claim,
# then consume them in the deployment above.
{{- if .Values.developmentVolumeMapping}}

---

apiVersion: v1
kind: PersistentVolume
metadata:
  name: {{.Values.serviceName}}
  namespace: {{.Values.serviceNamespace}}
  labels:
    service: {{.Values.serviceName}}
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  nfs:
    path: {{.Values.serviceLocation}}/service
    server: corectld

---

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{.Values.serviceName}}
  namespace: {{.Values.serviceNamespace}}
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
  selector:
    matchLabels:
      service: {{.Values.serviceName}}

# end of developmentVolumeMapping
{{- end }}

# If we want ingress for this servie we'll have to create it.
{{- if .Values.serviceIngress}}
---

kind: Ingress
apiVersion: extensions/v1beta1
metadata:
  name: {{.Values.serviceName}}
  namespace: {{.Values.serviceNamespace}}
  labels:
    app: {{.Values.ciEnvironmentSlug}}
    pipeline_id: "{{.Values.ciPipelineId}}"
    build_id: "{{.Values.ciBuildId}}"
  annotations:
    kubernetes.io/ingress.class: "nginx"
spec:
  tls:
  - hosts:
    - {{.Values.ciEnvironmentHostname}}
    secretName: wildcard-cert
  rules:
  - host: {{.Values.ciEnvironmentHostname}}
    http:
      paths:
      - path: /
        backend:
          serviceName: {{.Values.serviceName}}
          servicePort: 80
# end of serviceIngress
{{- end }}

# If we want a setup job for this servie we'll have to create it.
{{- if .Values.setupJob}}
---

apiVersion: batch/v1
kind: Job
metadata:
  name: {{.Values.serviceName}}-setup-{{ randAlphaNum 5 | lower }}
spec:
  activeDeadlineSeconds: {{.Values.setupJobTimeout}}
  template:
    metadata:
      name: {{.Values.serviceName}}-setup-{{ randAlphaNum 5 | lower }}
      labels:
        app: {{.Values.ciEnvironmentSlug}}
        pipeline_id: "{{.Values.ciPipelineId}}"
        build_id: "{{.Values.ciBuildId}}"
    spec:
      imagePullSecrets:
      - name: {{.Values.privateRegistryKey}}
      containers:
      - name: {{.Values.serviceName}}-setup
        image: {{.Values.serviceImage}}:{{.Values.serviceImageTag}}
        imagePullPolicy: {{.Values.pullPolicy}}
        env:
        - name: SERVICE_NAME
          value: {{.Values.serviceName}}
        - name: SERVICE_TYPE
          value: {{.Values.serviceType}}
        - name: SERVICE_SCOPE
          value: {{.Values.serviceScope}}
        - name: CI_PIPELINE_ID
          value: "{{.Values.ciPipelineId}}"
        - name: CI_BUILD_ID
          value: "{{.Values.ciBuildId}}"
        - name: SERVICE_ENVIRONMENT
          value: "{{.Values.serviceEnvironment}}"
        - name: SERVICE_BRANCH
          value: "{{.Values.serviceBranch}}"
        {{- range $name, $value := .Values.envVars }}
        - name: {{ $name }}
          value: {{ $value | quote }}
        {{- end}}
        args:
        - "ash"
        - "/setup.sh"
      restartPolicy: Never
{{- end }}
